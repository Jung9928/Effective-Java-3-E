# Item 39. 명명 패턴보다 애너테이션을 사용하라

### 내용 요약 <br>
1. `명명 패턴`의 한계
    - 오류 가능성
        - 메소드 이름에 특정 패턴을 포함시키는 방식 (ex : `test`로 시작하는 메소드)은 실수하기 쉽고 <br>
          컴파일 타임에 오류를 잡아내지 못한다. <br><br>

    - 가독성 저하
        - 코드의 의미가 명확하지 않고, 유지보수 시 혼동이 발생할 수 있다. <br><br>

    - 유연성 부족
        - 명명 패턴은 메타데이터를 표현하기에 제한적이며, 다양한 메타데이터를 관리하기 어렵다. <br><br>

2. `애너테이션`의 장점
    - 컴파일 타임 검증
        - 애너테이션은 잘못된 사용을 컴파일 타임에 잡아낼 수 있으며, 리플렉션을 통해 런타임에 메타데이터를 안전하게 처리할 수 있다. <br><br>

    - 가독성
        - 애너테이션은 코드에 명확하게 의미를 부여하며, 메타데이터를 쉽게 이해할 수 있다. <br><br>

    - 확장성
        - 사용자 정의 애너테이션을 만들어 다양한 메타데이터를 표현할 수 있다. <br><br>


3. JUnit의 예
   - 과거에는 테스트 메소드를 식별하기 위해 `test`로 시작하는 메소드 이름을 사용했다. <br>
     그러나 JUnit4 부터는 `@Test` 애너테이션을 사용하여 테스트 메소드를 명확하게 표시할 수 있다. <br><br>
   
   - `@Test` 애너테이션은 메소드가 테스트 메소드임을 명확히 나타내고, 추가적인 메타데이터 (ex: 예외, 타임아웃 등)를 표현할 수 있다. <br><br>


<br><br>

### `명명 패턴`을 사용한 경우
```java
public class MyTests {
    
    // 명명 패턴을 통해 테스트 메소드를 식별
   public void testMethod1() {
       // 테스트 코드
   }
   
   public void testMethod2() {
       // 테스트 코드
   }
   
   // 테스트 메소드로 사용하려 했지만 이름이 잘못되어 실행되지 않음
   public void methodTest3() {
       // 테스트 코드
   }
}
```
위 코드에서 메소드 이름에 `test`를 포함시켜 테스트 메소드를 식별하려 했다. <br>
이 접근 방식은 오류를 유발할 가능성이 크고, 코드의 의미를 명확히 드러내지 못한다. <br><br>


<br><br>

### `애너테이션`을 사용하는 경우
```java
import org.junit.Test;

public class MyTests {
    
   @Test
   public void method1() {
       // 테스트 코드
   }
   
   @Test
   public void method2() {
       // 테스트 코드
   }
   
   // 이름이 중요하지 않으며, @Test 애너테이션으로 명확하게 테스트 메소드임을 표시
   @Test
   public void method3() {
       // 테스트 코드
   }
}
```
위 코드에선, JUnit의 `@Test` 애너테이션을 사용하여 메소드가 테스트 메소드임을 명확히 표현했다. <br>
이 방법은 코드의 가독성을 높이고, 컴파일 타임에 오류를 잡아낼 수 있으며 이름에 의존하지 않으므로 실수 가능성을 줄인다. <br><br>


<br><br>


### 정리하자면
`애너테이션`을 사용하면 코드에 메타데이터를 명확하고 안전하게 추가할 수 있다. <br>
이는 유지보수성, 확장성, 그리고 오류 방지 측면에서 큰 이점을 제공한다. <br>
그러므로, 메타데이터를 처리할 때는 명명 패턴보다 `애너테이션`을 사용하는 것이 바람직하다.
