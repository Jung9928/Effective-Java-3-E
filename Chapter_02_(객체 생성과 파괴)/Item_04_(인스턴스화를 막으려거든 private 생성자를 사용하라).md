# Item 04. 인스턴스화를 막으려거든 private 생성자를 사용하라

### 내용 요약 <br>
1. 정적 메소드와 정적 필드만을 가진 클래스
    - 수학 함수나 유틸리티 기능처럼 특정 인스턴스 상태 없이 동작하는 `정적 메소드`만을 제공하는 클래스를 만들 때, 이러한 클래스의 `인스턴스화는 불필요`하다. <br><br>

    - 그러나 자바에서는 기본적으로 `명시적인 생성자를 제공하지 않으면 컴파일러가 기본 생성자를 자동으로 추가`하기 때문에, <br>
      인스턴스를 생성하지 못하도록 `private 생성자`를 추가해야 한다. <br><br>

2. 인스턴스화 방지 방법
    - 클래스를 인스턴스화하지 못하도록 하려면 `private 생성자를 선언`하여 외부에서 객체를 생성할 수 없도록 해야 한다. <br>
      이로써 클래스가 `불필요하게 인스턴스화`되는 것을 방지한다. <br><br>

3. private 생성자의 특징
    - 이 방법은 클래스가 의도하지 않게 `인스턴스화되는 것을 확실하게 방지`할 수 있다. <br><br>

    - 클래스 내부에서도 인스턴스를 생성할 수 없으므로, `절대 인스턴스화되지 않는다는 보장`을 제공한다. <br><br>

4. 상속 불가능
    - private 생성자는 서브클래싱을 방지할 수 있으므로, 의도치 않은 `상속`도 차단할 수 있다. <br><br>


5. 경고 목적
   - 이 기법은 코드 상에서 `명시적으로 경고의 역할`을 한다. <br>
     클래스가 오직 `정적 메소드`나 `정적 필드`로만 이루어져 있어 인스턴스화가 의미 없다는 사실을 명확히 알려준다. <br><br>


<br><br>


### 예시 코드
```java
public class UtilityClass {
    
    // private 생성자
    private UtilityClass() {
        throw new AssertionError();         // 인스턴스화 방지를 명확히 표현
    }
    
    public static void utilityMethod() {
        System.out.println("이것은 유틸리티 메소드");
    }
}

public class Main {

   public static void main(String[] args) {
       // UtilityClass util = new UtilityClass(); // 컴파일 오류: 생성자가 private
       UtilityClass.utilityMethod(); // 정적 메소드는 정상적으로 호출 가능
   }
}

```
위 코드에서 `UtilityClass`는 `정적 메소드`만을 가지고 있는 클래스이다. <br>
`private 생성자`가 있어 클래스 외부에서 객체를 생성할 수 없다. <br>
생성자 내부에서 `throw new AssertionError()`를 호출하여 실수로라도 클래스 내부에서 인스턴스가 생성되면 `예외`를 던지도록 하였다. <br>
이 기법은 `인스턴스화를 명확히 막고, 의도를 분명히` 나타낸다. <br><br>

`new UtilityClass()`는 `컴파일 오류`를 발생시킨다. `private 생성자` 덕분에 외부에서 인스턴스를 만들 수 없기 때문이다. <br>
하지만 `UtilityClass.utilityMethod()`와 같은 `정적 메소드 호출은 정상적으로 동작`한다. <br><br>

<br><br>


### 정리하자면
1. `정적 메소드`와 `정적 필드`만을 제공하는 `유틸리티 클래스`는 `private 생성자`를 사용하여 `인스턴스화되지 않도록`해야 한다. <br>
2. `private 생성자`를 명시적으로 선언하여, 실수로 클래스가 인스턴스화되는 것을 방지하고 `의도를 명확히`한다
3. 내부적으로 `AssertionError`를 던지면 `인스턴스화 자체를 더 명확하게 차단`할 수 있다. 
4. 이 기법은 클래스가 `상속되지 않도록`하는 효과도 있다
5. 인스턴스화가 불필요한 `유틸리티 클래스`는 `private 생성자`를 사용하여 인스턴스 생성을 차단하는 것이 좋으며, 이는 클래스 설계의 명확성과 안전성을 보장하는 중요한 패턴이다.



